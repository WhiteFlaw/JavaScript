闭包函数是声明在另一个函数内的函数
《JS高级程序设计-第3版》闭包是指有权访问另外一个函数作用域中的变量的函数
这个闭包函数可以访问[包裹其的函数]内的各种参数和变量,即便外部函数被return(生命终结)

特点: 
让外部得以访问函数内部的变量;
避免了全局变量的使用,防止了全局变量污染;
局部变量可以常驻内存不被回收,但这样也会导致内存泄漏;

____________________________________________________________________________

局部变量可以常驻内存不被回收:


将变量的值始终保存在内存中使其免于被销毁
一般情况下,函数执行完毕后,在JS垃圾回收机制的作用下函数内部的局部活动对象就会被销毁,
内存中仅仅保存全局作用域.

如果某个父函数内还存在另一个子函数(即内部的闭包函数),
子函数又能在外部被调用,并且子函数还使用了父函数内的变量的话,
按照我们的思路,垃圾回收机制在执行时必然会出现一些问题,出于内部函数对外部函数的依赖性,如果调用了外部函数执行完返回后,
又去单独调用内部的闭包函数,那么内部的闭包函数会由于获取不到外部函数的变量而出现问题;

所以为了避免出现这种问题,JS解释器并没有这样设计,
webpack打包的时候一样,把这个文件依赖到的所有其他文件都进行查找打包
JS解释器会自动的把子函数和它所需要的各种依赖(包括本地变量和祖先函数的变量)全部一起保存下来
这些被保存起来的变量不会被内存回收器回收,直到确认子函数不会再被调用(子函数被删除或者失去指针)为止

____________________________________________________________________________________________________

导致内存泄漏:


这样就解释了为什么不会被回收,那么不会回收就会被保存在内存里,内存总是有限的,(每次调用都会创建一个)所以;


____________________________________________________________________________________________________

使用立即执行函数与闭包配合来保存某些值


由于作用域链的配置机制，闭包函数在取父函数变量时只能取得变量的最后一个值;
例子:
function createFunction() {
    var result = new Array();
    for( var i = 0; i<10; i++) {
    //将函数赋值给每个数组元素;
        result[i] = function() {
            return i;
        };

    }
    return result;
}

var aa = createFunction();
alert(aa[0]()); //10
alert(aa[1]()); //10

父函数有个i++,加到10停止,那子函数就只能获取到i=10,无论什么时候,因为在此例子中所有子函数作用域链中保存的都是父函数的活动对象,所以取到的是同一个i。
即说明了闭包中所保存的是整个活动对象，而不是某一个特殊的变量,这种机制并不是我们想要的。
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
PS:立即执行函数的另一种写法:
(function() {
//函数体;
 })(); //小括号里可以传参
一般情况下只对匿名函数使用立即执行型函数(IIFE),避免污染全局作用域的同时使IIFE内部形成一个单独的作用域.
function() {
//函数体;
 }();//该函数无法执行,因为JS引擎看到function关键字后会认为你要声明函数,
然后就开始以函数声明标准规范你后续的代码,最终JS引擎发现你用一个小括号结束了你的函数,它觉得这是错的.
我们不能否定它判定的规则,所以不能让JS引擎认为写了function就是要声明函数,我们需要让它认为我们要写函数表达式:
var myFunction = function () { /* logic here */ };  //函数表达式基本样式;
var myObj = {
 myFunction: function () { /* logic here */ }
};
不要让JS引擎先看到function关键字而是先看到小括号,它就会觉得你在写表达式;

立即执行函数执行完成后也会被销毁回收,所以外界无法引用其内部的变量???
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

把需要保存的值传入闭包函数进行保存,但是需要避免闭包函数"在取父函数变量时只能取得变量的最后一个值"的特性,所以需要用到立即执行函数;
function createFunction() {
    var result = new Array();
    for( var i = 0; i<10; i++) {
        result[i] = function(num) {
- - - - - - - - - - - - - - - - - - - - - - - 
//闭包函数,它依赖到了外部立即执行函数的num,
//所以num会连同闭包函数被保存下来免于销毁;
//这样result数组中被赋值进去的每个函数都有一个自己的num，返回各自不同数值
            return function() {
                return num;
            };
- - - - - - - - - - -  - -- - -  -- - - - -  
        }(i);
     //i的值被赋给了num,;
    }
    return result;
}

var bb = createFunction();
alert(bb[0]()); //0
alert(bb[1]()); //1

闭包保存num完成


附例:
function bar(value) {
  var testValue = 'inner';
  
  var rusult = testValue + value;
  
  function innser() {
     return rusult;
  };
  
  return innser();
}

console.log(bar('fun'));		// "innerfun"
